# NapSAT solver

## Description

This git contains the SAT solver of a modular SMT Solver called modulariT. ModulariT is a project lead by Pr. Pascal Fontaine and whose goal is to create a modular SMT Solver in C++ for academic and research purposes.

NapSAT is inspired by the MiniSAT but (will) support incremental solving, hints and other useful features for SMT solving.

The solver was written by Robin Coutelier as a follow-up to his master thesis on "Chronological vs. Non-Chronological Backtracking in SMT Solving" and is currently work in progress. It was partially written while working at the University of Liège, Belgium, and the project is still ongoing at the TU Wien, Austria (as of 2024) under the supervision of Pr. Laura Kovács.

The goal of this project is to create a flexible SAT solver that implements both chronological and non-chronological backtracking while still supporting standard SMT features such as incremental solving, hints, etc.

The solver also implements an observer pattern that allow easy debugging, and automatic tikz graph generation for the trail, the clause set and the implication graph. This is useful for understanding the history of the bug, and generating slides for presentations.

### Contributions

This solver brings the contribution of Lazy Strong Chronological Backtracking. A method used to enforce stronger invariants to chronological backtracking, and to reduce the number of propagations while never missing unit implications. A paper on this topic is currently being written and will be submitted to SAT 2024.

## Installation

### Building

The project uses Make to generate the build files. To build the project as a library, simply run the following commands:

```bash {"id":"01HRQ2SDACEHDTX86EN4FH6562"}
make
```

This will generate the build files and compile the project. The executable will be located in the build folder.
You can also build a library by running `make lib` or `make all`.

A debug version can be generated by running the following commands:

```bash {"id":"01HRQ2SDAD54CFP30XNWJG3DDN"}
make debug
```

This will generate the build files and compile the project with debug flags (including the library). The executable will be located in the build folder. In debug mode, the executable will be named `NapSAT`. This executable aggressively checks for invariant violations and will be much slower than the release version.

## Usage

Building the project will generate two executables in the build folder: `NapSAT-*version*` and `test-SAT`. The first one is the SAT solver itself and the second one is the unit tests executable. The unit tests are not very elaborate at the moment, and will be improved in the future.

### Running the SAT solver

The SAT solver can be run with the following command:
```bash
./NapSAT <input-file> [options]
```

The input file must be a valid DIMACS CNF file. The solver will then try to solve the given formula and print the result on the standard output.

### Function calls
NapSAT can be used as a library. The API is defined in `include/SAT-API.hpp`. This allows a more abstract use of the solver. However, advanturous users can also use the internal API defined in `src/solver/NapSAT.hpp`. However, since this project is not yet stable, the internal API is subject to change.

### Functionalities
#### Chronological Backtracking
The main contribution of NapSAT is the implementation of different chronological backtracking strategies that can be selected at runtime. The different versions are described in a paper that is currently under submission.

#### Observing
An observer can be attached to the solver to check and debug the solver. The observer can be used to generate tikz figures of the trail, the clause set and the implication graph. This is useful for creating slides for presentations.

It also allows the user to check the behavior of the solver with a configurable level of detail. This can be useful for debugging large formulas.

Furthermore, the interactive mode if the solver allows the user to interact with the solver during runtime. Chosing specific decisions or learning clauses can be done interactively. For bug reproduction, this functionality can be accompanied by a command file that will be executed by the solver.

For example, the follwing command shows the behavior of the solver in lazy strong chronological backtracking mode on a specific test case:
One can set the navigation level to show more details. use the command `set level 10` to show all details.

```bash {"id":"01HY3JFHKX9XFSMFV3FCKMT46S"}
build/NapSAT test-cnf/test-trigger-mli.cnf -i -commands test-cnf/test-trigger-commands.txt -lscb
```


#### Proof generation
The solver generates proofs for UNSAT formulas. The proof can be printed in a human-readable format or simply checked using the options `-pp` and `-cp` respectively.

```bash {"id":"01HY3JP30T3GT3XST25X9BDT9R"}
build/NapSAT test-cnf/unsat-01.cnf -pp
```

## List of objectives for the future

- The display is currently only in the form of terminal output. The goal is to create a nice user interface for the solver, and to allow naming of variables and clauses, and to display the implication graph in a more user-friendly way. This is left for future work.
- The solver currently only supports the DIMACS CNF format. We would like to add support for any arbitrary propositional formula in the future.
- The solver does not support theory propagations yet.
- The solver does not support user propagation yet.
- The solver does not support additional theories. We would like to add AMO constraints, and be flexible enough to be easily hackable and add other simple theories.
- The solver does not support assumptions yet.
- The solver does not provide unsat cores yet.

## License

This project is not under any license yet, but the author allows anyone to use, modify and redistribute the code as long as the author is credited and the code is not used for commercial purposes.

## Contact

If you have any questions or suggestions, feel free to contact me at robin.coutelier@gmail.com.
